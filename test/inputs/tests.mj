(*
mux_n<n, p>(switch:[n], cases:[2^n, p]) = o:[_] where
    if n = 0 then
        o = cases[0];
    else
        o = mux(switch[0], mux_n(switch[1..], cases[..2^n-1]), mux_n(switch[1..], cases[2^n..]));
    end if
end where
*)

update_addr<n, p>(addr:[n], data:[p], mem:[2^n, p]) = mem2:[2^n, p] where
    if n = 0 then
        mem2 = [data];
    else
        mem2 = mux(addr[0],
            update_addr(addr[1..], data, mem[..2^(n-1) - 1]) . mem[2^(n-1) .. ],
            mem[..2^(n-1) - 1]) . update_addr(addr[1..], data, mem[2^(n-1) .. ])
    end if
end where

(*
main(clk1) = (o2) where
  front_edge3 = clk1 && not(reg clk1);
  down_edge4 = not(clk1) && reg clk1;

  o110 = 1;
  o08 = 0;
  o2 = mux(reg nx_stateauto1st0[1], o110, o08);

  nx_stateauto1st19 = mux(front_edge3, 10, 01);
  nx_stateauto1st07 = mux(down_edge4, 01, 10);
  nx_stateauto1st0 = mux(reg nx_stateauto1st0[1],
                             nx_stateauto1st19,
                             nx_stateauto1st07)
end where;
*)
(*
main() = () where
  i = [[0b100, 0b001]];
  o = i[0, .. , 0..1];
  a = recursive<4, 2>(0b0101)
end where


fulladder(a,b,c) = (s, r) where
  s = (a xor b) xor c;
  r = (a and b) or ((a xor b) and c)
end where

minus(x) = (y) where
  y = x xor c;
  c = reg (x or y)
end where

cm2(x) = (s, r) where
  s = reg (x xor s);
  r = x and s
end where

clk2() = (o) where
  o = reg(c);
  c = not (reg (o))
end where

recursive<n, p>(i:[n]) = o where
  if p >= n then
    o = i[p-1]
  else
    o = recursive<n, p+1>(i)
  end if
end where
*)
